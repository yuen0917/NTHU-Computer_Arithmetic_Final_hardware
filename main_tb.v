`timescale 1ns/1ps
// ============================================================
// Main Testbench
// ============================================================

module main_tb;

    // ============================================================
    // 1. Parameters and Constants
    // ============================================================
    // Image file name (generated by Python script)
    parameter IMG_FILE = "test_image.txt"; // True label: 6

    // Weight file name (must be consistent with the $readmemh file name in the RTL)
    parameter W_FILE_L1 = "conv1_relu.txt";
    parameter W_FILE_L2 = "conv2_selu.txt";
    parameter W_FILE_L3 = "conv3_gelu.txt";
    parameter W_FILE_FC = "fc_weights.txt";
    parameter B_FILE_FC = "fc_biases.txt";

    // Image parameters
    parameter IMG_W = 28;
    parameter IMG_H = 28;
    parameter PADDING = 1; // Layer 1 needs Padding

    // ============================================================
    // 2. Signals Declaration
    // ============================================================
    reg          clk;
    reg          rst_n;
    reg          in_valid;
    reg  [7:0]   in_data;

    wire [3:0]   class_out;
    wire         class_valid;
    wire signed [31:0] final_score;
    wire         fc_out_valid;

    // Memory: Store the imported MNIST image (784 bytes)
    reg [7:0] img_mem [0:IMG_W*IMG_H-1];

    integer i, r, c;
    integer file_handle;
    integer valid_pixel_idx;

    // ============================================================
    // 3. DUT Instantiation (Top Module)
    // ============================================================
    main u_top (
        .clk         (clk),
        .rst_n       (rst_n),
        .in_valid    (in_valid),
        .in_data     (in_data),
        .class_out   (class_out),
        .class_valid (class_valid),
        .final_score (final_score),
        .fc_out_valid(fc_out_valid)
    );

    // ============================================================
    // 4. Clock Generation (100MHz)
    // ============================================================
    initial begin
        clk = 0;
        forever #5 clk = ~clk;
    end

    // ============================================================
    // 5. Initialization and Test Flow
    // ============================================================
    initial begin
        $display("==================================================");
        $display("  Start System Simulation - MNIST CNN ");
        $display("==================================================");

        // ============================================================
        // A. Generate Dummy Weight File (Only for testing, if there are real weights, please comment out this section)
        // ============================================================
        // Layer 1 (1x8x3x3 = 72 weights)
        // file_handle = $fopen(W_FILE_L1, "w");
        // for(i=0; i<72; i=i+1) $fdisplay(file_handle, "%h", ($random % 21) - 10);
        // $fclose(file_handle);

        // // Layer 2 (8x16x3x3 = 1152 weights)
        // file_handle = $fopen(W_FILE_L2, "w");
        // for(i=0; i<1152; i=i+1) $fdisplay(file_handle, "%h", ($random % 21) - 10);
        // $fclose(file_handle);

        // // Layer 3 (16x32x3x3 = 4608 weights)
        // file_handle = $fopen(W_FILE_L3, "w");
        // for(i=0; i<4608; i=i+1) $fdisplay(file_handle, "%h", ($random % 21) - 10);
        // $fclose(file_handle);

        // // FC Weights (32x10 = 320 weights)
        // file_handle = $fopen(W_FILE_FC, "w");
        // for(i=0; i<320; i=i+1) $fdisplay(file_handle, "%h", ($random % 21) - 10);
        // $fclose(file_handle);

        // // FC Biases (10 biases)
        // file_handle = $fopen(B_FILE_FC, "w");
        // for(i=0; i<10; i=i+1) $fdisplay(file_handle, "%h", 0);
        // $fclose(file_handle);

        // $display("[TB] Dummy weight files generated/checked.");

        // ============================================================
        // B. Read MNIST Image
        // ============================================================
        // Please ensure the mnist_image.txt generated by python is in the same directory
        // If the file does not exist, you can fill in random values here to prevent the simulator from reporting an error
        file_handle = $fopen(IMG_FILE, "r");
        if (file_handle == 0) begin
            $display("[WARNING] %s not found! Using random image data.", IMG_FILE);
            for (i = 0; i < 784; i = i + 1) img_mem[i] = $random % 256;
        end else begin
            $fclose(file_handle);
            $readmemh(IMG_FILE, img_mem);
            $display("[TB] Loaded image from %s", IMG_FILE);
        end

        // ============================================================
        // C. Force Load Weights to DUT (Backdoor Load)
        // ============================================================
        // This is to ensure that at simulation time 0, the RTL can read the file just generated
        // Note: The path name must correspond to the internal instance name of your main.v
        $readmemh(W_FILE_L1, u_top.u_layer1.weight_data);
        $readmemh(W_FILE_L2, u_top.u_layer2.weight_data);
        $readmemh(W_FILE_L3, u_top.u_layer4.weight_data); // Note: layer4 in main corresponds to conv2d_layer3
        $readmemh(W_FILE_FC, u_top.u_fc.weights);
        $readmemh(B_FILE_FC, u_top.u_fc.biases);

        // Also needs gelu.txt (Layer 4 used)
        // $readmemh("import_file/gelu.txt", u_top.u_layer4.gelu_lut_inst.gelu_table); // If needed

        // ============================================================
        // D. Start Simulation
        // ============================================================
        rst_n    = 1;
        in_valid = 0;
        in_data  = 0;

        #20 rst_n = 0; // Reset System
        #20 rst_n = 1;
        #10;

        $display("[TB] Start Streaming Image Data (28x28 NO PADDING)...");
        in_valid = 1;

        // 改為只送 28x28
        for (r = 0; r < IMG_H; r = r + 1) begin
            for (c = 0; c < IMG_W; c = c + 1) begin
                valid_pixel_idx = r * IMG_W + c;
                in_data = img_mem[valid_pixel_idx];
                @(posedge clk);
                #1;
            end
        end

        // 【關鍵修正】Flush Pipeline
        // 繼續送 Dummy Data (0)，並保持 in_valid = 1
        // 這會把滯留在 Line Buffer 裡的最後幾行資料「擠」到下一層
        // 我們有 3 層 Conv，每層延遲約 1 行，加上 MaxPool，建議多送 5~10 行
        $display("[TB] Flushing Pipeline...");
        in_data = 0;
        in_valid = 1; // 保持 Valid!

        for (i = 0; i < 10 * IMG_W; i = i + 1) begin
             @(posedge clk);
             #1;
        end

        // Flush 完畢，關閉 Valid
        in_valid = 0;
        $display("[TB] Input Stream Finished. Waiting for output...");

        // ============================================================
        // E. Wait for Output Result
        // ============================================================
        // Set a long enough Timeout, wait for CNN Pipeline to finish
        // Estimated delay: Conv1(28*28) + Conv2(28*28) + MP + Conv3(14*14) + GAP + FC
        // Conservative estimate: 5000 cycles
        fork : wait_output
            begin
                wait(class_valid);
                $display("\n==================================================");
                $display("  INFERENCE COMPLETE");
                $display("==================================================");
                $display("  Predicted Class: %0d", class_out);
                $display("  Max Score (z):   %0d", final_score);
                $display("==================================================\n");
                disable wait_output;
            end
            begin
                repeat(20000) @(posedge clk);
                $display("\n[ERROR] Simulation Timeout! No output received.");
                disable wait_output;
            end
        join

        $finish;
    end

endmodule