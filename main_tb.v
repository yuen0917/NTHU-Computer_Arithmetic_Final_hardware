`timescale 1ns/1ps
// ============================================================
// Main Testbench
// ============================================================

module main_tb;

    // ============================================================
    // 1. Parameters and Constants
    // ============================================================
    // Image file name (generated by Python script)
    parameter IMG_FILE = "test_image.txt";

    // Weight file name (must be consistent with the $readmemh file name in the RTL)
    parameter W_FILE_L1 = "conv1_relu.txt";
    parameter W_FILE_L2 = "conv2_selu.txt";
    parameter W_FILE_L3 = "conv3_gelu.txt";
    parameter W_FILE_FC = "fc_weights.txt";
    parameter B_FILE_FC = "fc_biases.txt";

    // Image parameters
    parameter IMG_W = 28;
    parameter IMG_H = 28;
    parameter PADDING = 1; // Layer 1 needs Padding

    // ============================================================
    // 2. Signals Declaration
    // ============================================================
    reg          clk;
    reg          rst_n;
    reg          in_valid;
    reg  [7:0]   in_data;

    wire [3:0]   class_out;
    wire         class_valid;
    wire         fc_out_valid;
    wire signed [31:0] class_value;
    wire signed [31:0] final_score;

    // Memory: Store the imported MNIST image (784 bytes)
    reg [7:0] img_mem [0:IMG_W*IMG_H-1];

    integer i, r, c;
    integer file_handle;
    integer valid_pixel_idx;

    // ============================================================
    // 3. DUT Instantiation (Top Module)
    // ============================================================
    main u_top (
        .clk         (clk),
        .rst_n       (rst_n),
        .in_valid    (in_valid),
        .in_data     (in_data),
        .class_out   (class_out),
        .class_valid (class_valid),
        .class_value (class_value),
        .final_score (final_score),
        .fc_out_valid(fc_out_valid)
    );

    // ============================================================
    // 4. Clock Generation (100MHz)
    // ============================================================
    initial begin
        clk = 0;
        forever #5 clk = ~clk;
    end

    // ============================================================
    // 5. Initialization and Test Flow
    // ============================================================
    initial begin
        $display("==================================================");
        $display("  Start System Simulation - MNIST CNN ");
        $display("==================================================");

        // ============================================================
        // A. Generate Dummy Weight File (Only for testing, if there are real weights, please comment out this section)
        // ============================================================
        // Layer 1 (1x8x3x3 = 72 weights)
        // file_handle = $fopen(W_FILE_L1, "w");
        // for(i=0; i<72; i=i+1) $fdisplay(file_handle, "%h", ($random % 21) - 10);
        // $fclose(file_handle);

        // // Layer 2 (8x16x3x3 = 1152 weights)
        // file_handle = $fopen(W_FILE_L2, "w");
        // for(i=0; i<1152; i=i+1) $fdisplay(file_handle, "%h", ($random % 21) - 10);
        // $fclose(file_handle);

        // // Layer 3 (16x32x3x3 = 4608 weights)
        // file_handle = $fopen(W_FILE_L3, "w");
        // for(i=0; i<4608; i=i+1) $fdisplay(file_handle, "%h", ($random % 21) - 10);
        // $fclose(file_handle);

        // // FC Weights (32x10 = 320 weights)
        // file_handle = $fopen(W_FILE_FC, "w");
        // for(i=0; i<320; i=i+1) $fdisplay(file_handle, "%h", ($random % 21) - 10);
        // $fclose(file_handle);

        // // FC Biases (10 biases)
        // file_handle = $fopen(B_FILE_FC, "w");
        // for(i=0; i<10; i=i+1) $fdisplay(file_handle, "%h", 0);
        // $fclose(file_handle);

        // $display("[TB] Dummy weight files generated/checked.");

        // ============================================================
        // B. Read MNIST Image
        // ============================================================
        // Please ensure the mnist_image.txt generated by python is in the same directory
        // If the file does not exist, you can fill in random values here to prevent the simulator from reporting an error
        file_handle = $fopen(IMG_FILE, "r");
        if (file_handle == 0) begin
            $display("[WARNING] %s not found! Using random image data.", IMG_FILE);
            for (i = 0; i < 784; i = i + 1) img_mem[i] = $random % 256;
        end else begin
            $fclose(file_handle);
            $readmemh(IMG_FILE, img_mem);
            $display("[TB] Loaded image from %s", IMG_FILE);
        end

        // ============================================================
        // C. Force Load Weights to DUT (Backdoor Load)
        // ============================================================
        // This is to ensure that at simulation time 0, the RTL can read the file just generated
        // Note: The path name must correspond to the internal instance name of your main.v
        $readmemh(W_FILE_L1, u_top.u_layer1.weight_data);
        $readmemh(W_FILE_L2, u_top.u_layer2.weight_data);
        $readmemh(W_FILE_L3, u_top.u_layer4.weight_data); // Note: layer4 in main corresponds to conv2d_layer3
        $readmemh(W_FILE_FC, u_top.u_fc.weights);
        $readmemh(B_FILE_FC, u_top.u_fc.biases);

        // Also needs gelu.txt (Layer 4 used)
        // $readmemh("import_file/gelu.txt", u_top.u_layer4.gelu_lut_inst.gelu_table); // If needed

        // ============================================================
        // D. Start Simulation
        // ============================================================
        rst_n    = 1;
        in_valid = 0;
        in_data  = 0;

        #20 rst_n = 0; // Reset System
        #20 rst_n = 1;
        #10;

        $display("[TB] Start Streaming Image Data (28x28 NO PADDING)...");
        in_valid = 1;

        // Send 28x28 image data
        for (r = 0; r < IMG_H; r = r + 1) begin
            for (c = 0; c < IMG_W; c = c + 1) begin
                valid_pixel_idx = r * IMG_W + c;
                in_data = img_mem[valid_pixel_idx];
                @(posedge clk);
                #1;
            end
        end

        // Flush Pipeline
        // Send Dummy Data (0) and keep in_valid = 1
        // This will push the last few rows of data in the Line Buffer to the next layer
        // We have 3 Conv layers, each with a delay of about 1 row, plus MaxPool, so we should send 5~10 more rows
        $display("[TB] Flushing Pipeline...");
        in_data = 0;
        in_valid = 1; // Keep Valid!

        for (i = 0; i < 10 * IMG_W; i = i + 1) begin
             @(posedge clk);
             #1;
        end

        // Flush complete, close Valid
        in_valid = 0;
        $display("[TB] Input Stream Finished. Waiting for output...");

        // ============================================================
        // E. Wait for Output Result
        // ============================================================
        // Set a long enough Timeout, wait for CNN Pipeline to finish
        // Estimated delay: Conv1(28*28) + Conv2(28*28) + MP + Conv3(14*14) + GAP + FC
        // Conservative estimate: 5000 cycles
        fork : wait_output
            begin
                wait(class_valid);
                $display("\n==================================================");
                $display("  INFERENCE COMPLETE");
                $display("==================================================");
                $display("  Predicted Class: %0d", class_out);
                $display("  Class Value:     %0d", class_value);
                $display("==================================================\n");
                disable wait_output;
            end
            begin
                repeat(20000) @(posedge clk);
                $display("\n[ERROR] Simulation Timeout! No output received.");
                disable wait_output;
            end
        join

        $finish;
    end

    // ============================================================
    // 6. Debug Monitor (Row 14 Comparison)
    // ============================================================
    integer p_cnt_l1 = 0;
    integer p_cnt_l2 = 0;
    integer p_cnt_l3 = 0;
    integer p_cnt_gap = 0;

    // Layer 1 (28x28): Row 14 starts at 14*28 = 392
    localparam L1_START = 14 * 28;
    localparam L1_END   = 14 * 28 + 10; // Print 10 pixels

    // Layer 2 (28x28): Row 14 starts at 14*28 = 392
    localparam L2_START = 14 * 28;
    localparam L2_END   = 14 * 28 + 10;

    // Layer 3 (14x14): Row 7 (Center) starts at 0 to 27
    localparam L3_START = 0;
    localparam L3_END   = 28;

    always @(posedge clk) begin
        // --- Layer 1 Monitor ---
        if (u_top.l1_valid) begin
            if (p_cnt_l1 >= L1_START && p_cnt_l1 < L1_END) begin
                $display("[DEBUG L1] Row 14 Col %0d | Val = %d",
                         p_cnt_l1 - L1_START, u_top.l1_out0);
            end
            p_cnt_l1 = p_cnt_l1 + 1;
        end

        // --- Layer 2 Monitor ---
        if (u_top.l2_valid) begin
            if (p_cnt_l2 >= L2_START && p_cnt_l2 < L2_END) begin
                $display("[DEBUG L2] Row 14 Col %0d | Val = %d",
                         p_cnt_l2 - L2_START, u_top.l2_out0);
            end
            p_cnt_l2 = p_cnt_l2 + 1;
        end

        // --- Layer 3 Monitor ---
        if (u_top.l4_valid) begin
            if (p_cnt_l3 < L3_END) begin
                $display("[DEBUG L3] Pixel %0d | Val = %d",
                         p_cnt_l3, u_top.u_layer4.out_conv0);
            end
            p_cnt_l3 = p_cnt_l3 + 1;
        end

        // --- GAP / FC_IN Monitor ---
        // Print first 10 GAP values
        if (u_top.fc_in_valid) begin
            if (p_cnt_gap < 10) begin
                $display("[DEBUG GAP] Index %0d | Val = %d",
                         p_cnt_gap, u_top.fc_in_data);
            end
            p_cnt_gap = p_cnt_gap + 1;
        end
    end
endmodule