`timescale 1ns/1ps
// ============================================================
// Main Testbench
// ============================================================

module main_tb;

    // ============================================================
    // 1. Parameters and Constants
    // ============================================================
    // Image file name (generated by Python script)
    parameter IMG_FILE = "test_image.txt"; // True label: 5

    // Weight file name (must be consistent with the $readmemh file name in the RTL)
    parameter W_FILE_L1 = "conv1_relu.txt";
    parameter W_FILE_L2 = "conv2_selu.txt";
    parameter W_FILE_L3 = "conv3_gelu.txt";
    parameter W_FILE_FC = "fc_weights.txt";
    parameter B_FILE_FC = "fc_biases.txt";

    // Image parameters
    parameter IMG_W = 28;
    parameter IMG_H = 28;
    parameter PADDING = 1; // Layer 1 needs Padding

    // ============================================================
    // 2. Signals Declaration
    // ============================================================
    reg          clk;
    reg          rst_n;
    reg          in_valid;
    reg  [7:0]   in_data;

    wire [3:0]   class_out;
    wire         class_valid;
    wire         fc_out_valid;
    wire signed [31:0] class_value;
    wire signed [31:0] final_score;

    // Memory: Store the imported MNIST image (784 bytes)
    reg [7:0] img_mem [0:IMG_W*IMG_H-1];

    integer i, r, c;
    integer file_handle;
    integer valid_pixel_idx;

    // ============================================================
    // 3. DUT Instantiation (Top Module)
    // ============================================================
    main u_top (
        .clk         (clk),
        .rst_n       (rst_n),
        .in_valid    (in_valid),
        .in_data     (in_data),
        .class_out   (class_out),
        .class_valid (class_valid),
        .class_value (class_value),
        .final_score (final_score),
        .fc_out_valid(fc_out_valid)
    );

    // ============================================================
    // 4. Clock Generation (100MHz)
    // ============================================================
    initial begin
        clk = 0;
        forever #5 clk = ~clk;
    end

    // ============================================================
    // 5. Initialization and Test Flow
    // ============================================================
    initial begin
        $display("==================================================");
        $display("  Start System Simulation - MNIST CNN ");
        $display("==================================================");

        // ============================================================
        // A. Generate Dummy Weight File (Only for testing, if there are real weights, please comment out this section)
        // ============================================================
        // Layer 1 (1x8x3x3 = 72 weights)
        // file_handle = $fopen(W_FILE_L1, "w");
        // for(i=0; i<72; i=i+1) $fdisplay(file_handle, "%h", ($random % 21) - 10);
        // $fclose(file_handle);

        // // Layer 2 (8x16x3x3 = 1152 weights)
        // file_handle = $fopen(W_FILE_L2, "w");
        // for(i=0; i<1152; i=i+1) $fdisplay(file_handle, "%h", ($random % 21) - 10);
        // $fclose(file_handle);

        // // Layer 3 (16x32x3x3 = 4608 weights)
        // file_handle = $fopen(W_FILE_L3, "w");
        // for(i=0; i<4608; i=i+1) $fdisplay(file_handle, "%h", ($random % 21) - 10);
        // $fclose(file_handle);

        // // FC Weights (32x10 = 320 weights)
        // file_handle = $fopen(W_FILE_FC, "w");
        // for(i=0; i<320; i=i+1) $fdisplay(file_handle, "%h", ($random % 21) - 10);
        // $fclose(file_handle);

        // // FC Biases (10 biases)
        // file_handle = $fopen(B_FILE_FC, "w");
        // for(i=0; i<10; i=i+1) $fdisplay(file_handle, "%h", 0);
        // $fclose(file_handle);

        // $display("[TB] Dummy weight files generated/checked.");

        // ============================================================
        // B. Read MNIST Image
        // ============================================================
        // Please ensure the mnist_image.txt generated by python is in the same directory
        // If the file does not exist, you can fill in random values here to prevent the simulator from reporting an error
        file_handle = $fopen(IMG_FILE, "r");
        if (file_handle == 0) begin
            $display("[WARNING] %s not found! Using random image data.", IMG_FILE);
            for (i = 0; i < 784; i = i + 1) img_mem[i] = $random % 256;
        end else begin
            $fclose(file_handle);
            $readmemh(IMG_FILE, img_mem);
            $display("[TB] Loaded image from %s", IMG_FILE);
        end

        // ============================================================
        // C. Force Load Weights to DUT (Backdoor Load)
        // ============================================================
        // This is to ensure that at simulation time 0, the RTL can read the file just generated
        // Note: The path name must correspond to the internal instance name of your main.v
        $readmemh(W_FILE_L1, u_top.u_layer1.weight_data);
        $readmemh(W_FILE_L2, u_top.u_layer2.weight_data);
        $readmemh(W_FILE_L3, u_top.u_layer4.weight_data); // Note: layer4 in main corresponds to conv2d_layer3
        $readmemh(W_FILE_FC, u_top.u_fc.weights);
        $readmemh(B_FILE_FC, u_top.u_fc.biases);

        // Also needs gelu.txt (Layer 4 used)
        // $readmemh("import_file/gelu.txt", u_top.u_layer4.gelu_lut_inst.gelu_table); // If needed

        // ============================================================
        // D. Start Simulation
        // ============================================================
        rst_n    = 1;
        in_valid = 0;
        in_data  = 0;

        #20 rst_n = 0; // Reset System
        #20 rst_n = 1;
        #10;

        $display("[TB] Start Streaming Image Data (28x28 NO PADDING)...");
        in_valid = 1;

        // Send 28x28 image data
        for (r = 0; r < IMG_H; r = r + 1) begin
            for (c = 0; c < IMG_W; c = c + 1) begin
                valid_pixel_idx = r * IMG_W + c;
                in_data = img_mem[valid_pixel_idx];
                @(posedge clk);
                #1;
            end
        end

        // Flush Pipeline
        // Send Dummy Data (0) and keep in_valid = 1
        // This will push the last few rows of data in the Line Buffer to the next layer
        // We have 3 Conv layers, each with a delay of about 1 row, plus MaxPool, so we should send 5~10 more rows
        $display("[TB] Flushing Pipeline...");
        in_data = 0;
        in_valid = 1; // Keep Valid!

        for (i = 0; i < 10 * IMG_W; i = i + 1) begin
             @(posedge clk);
             #1;
        end

        // Flush complete, close Valid
        in_valid = 0;
        $display("[TB] Input Stream Finished. Waiting for output...");

        // ============================================================
        // E. Wait for Output Result
        // ============================================================
        // Set a long enough Timeout, wait for CNN Pipeline to finish
        // Estimated delay: Conv1(28*28) + Conv2(28*28) + MP + Conv3(14*14) + GAP + FC
        // Conservative estimate: 5000 cycles
        fork : wait_output
            begin
                wait(class_valid);
                $display("\n==================================================");
                $display("  INFERENCE COMPLETE");
                $display("==================================================");
                $display("  Predicted Class: %0d", class_out);
                $display("  Class Value:     %0d", class_value);
                $display("==================================================\n");
                disable wait_output;
            end
            begin
                repeat(20000) @(posedge clk);
                $display("\n[ERROR] Simulation Timeout! No output received.");
                disable wait_output;
            end
        join

        $finish;
    end

    // ============================================================
    // 6. Debug Monitor: Spy on internal signals
    // ============================================================
    // These counters are used to limit the number of prints to avoid flooding the console
    integer cnt_l1 = 0;
    integer cnt_l2 = 0;
    integer cnt_l3 = 0;
    integer cnt_fc = 0;
    integer cnt_gap = 0;

    always @(posedge clk) begin
        // --- Monitor Layer 1 (Conv1) Output ---
        // Path: u_top -> u_layer1 -> out_conv0
        if (u_top.l1_valid) begin
            if (cnt_l1 < 5) begin
                $display("[DEBUG L1] Time=%0t | Ch0 Val=%d | is_X?=%b",
                         $time, u_top.l1_out0, (u_top.l1_out0 === 8'bx));
                cnt_l1 = cnt_l1 + 1;
            end
            // If X is found, report an error (only once)
            if (u_top.l1_out0 === 8'bx && cnt_l1 != 999) begin
                $display("[ERROR] Layer 1 output contains X at time %0t!", $time);
                cnt_l1 = 999; // Lock to avoid repeated errors
            end
        end

        // --- Monitor Layer 2 (Conv2) Output ---
        if (u_top.l2_valid) begin
            if (cnt_l2 < 5) begin
                $display("[DEBUG L2] Time=%0t | Ch0 Val=%d | is_X?=%b",
                         $time, u_top.l2_out0, (u_top.l2_out0 === 8'bx));
                cnt_l2 = cnt_l2 + 1;
            end
            if (u_top.l2_out0 === 8'bx && cnt_l2 != 999) begin
                $display("[ERROR] Layer 2 output contains X at time %0t!", $time);
                cnt_l2 = 999;
            end
        end

        // --- Monitor Layer 3/4 (Conv3) Output ---
        // Note: In main.v, the third Conv instance is named u_layer4
        // And the output is connected to l4_out_w (Array)
        if (u_top.l4_valid) begin
            if (cnt_l3 < 5) begin
                // Here we directly look at the internal out_conv0 of u_layer4
                $display("[DEBUG L3] Time=%0t | Ch0 Val=%d | is_X?=%b",
                         $time, u_top.u_layer4.out_conv0, (u_top.u_layer4.out_conv0 === 8'bx));
                cnt_l3 = cnt_l3 + 1;
            end
            if (u_top.u_layer4.out_conv0 === 8'bx && cnt_l3 != 999) begin
                $display("[ERROR] Layer 3 (u_layer4) output contains X at time %0t!", $time);
                cnt_l3 = 999;
            end
        end

        // --- Monitor Layer 5 (GAP) Output ---
        // We directly observe the accumulator of the first GAP unit
        if (u_top.GAP_INST[0].u_gap.out_valid || u_top.l4_valid) begin
            // Observe if the accumulator of GAP became X
            if (u_top.GAP_INST[0].u_gap.sum_acc === 16'bx && cnt_gap == 0) begin
                $display("\n[ERROR] GAP Unit 0 Accumulator became X at time %0t!", $time);
                $display("        Input at this moment: %d (is_x: %b)",
                         u_top.GAP_INST[0].u_gap.in_data,
                         (u_top.GAP_INST[0].u_gap.in_data === 8'bx));
                cnt_gap = 1;
            end
        end

        // --- Monitor FC Input (After Flatten) ---
        if (u_top.fc_in_valid) begin
            if (cnt_fc < 5) begin
                $display("[DEBUG FC_IN] Time=%0t | Data=%d | is_X?=%b",
                         $time, u_top.fc_in_data, (u_top.fc_in_data === 8'bx));
                cnt_fc = cnt_fc + 1;
            end
            if (u_top.fc_in_data === 8'bx && cnt_fc != 999) begin
                $display("[ERROR] FC Input contains X at time %0t!", $time);
                cnt_fc = 999;
            end
        end


    end
endmodule